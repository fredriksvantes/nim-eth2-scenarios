diff --git a/yaml/serialization.nim b/yaml/serialization.nim
index 2d2ce74..6384a58 100644
--- a/yaml/serialization.nim
+++ b/yaml/serialization.nim
@@ -635,7 +635,7 @@ proc fieldCount(t: NimNode): int {.compiletime.} =
                inc(result, increment)
 
 
-macro matchMatrix(t: typedesc): untyped =
+macro matchMatrix(t: typed): untyped =
   result = newNimNode(nnkBracket)
   let numFields = fieldCount(t)
   for i in 0..<numFields:
@@ -707,7 +707,7 @@ proc ifNotTransient(tSym: NimNode, fieldIndex: int, content: openarray[NimNode],
           ": Field \"" & `fName` & "\" is transient and may not occur in input")
     ))
 
-macro ensureAllFieldsPresent(s: YamlStream, t: typedesc, tIndex: int, o: typed,
+macro ensureAllFieldsPresent(s: YamlStream, t: typed, tIndex: int, o: typed,
                              matched: typed): typed =
   let
     dbp = defaultBitvectorProc
@@ -948,7 +948,7 @@ proc constructObject*[O: object|tuple](
   ## Overridable default implementation for custom object and tuple types
   constructObjectDefault(s, c, result)
 
-macro genRepresentObject(t: typedesc, value, childTagStyle: typed): typed =
+macro genRepresentObject(t: typed, value, childTagStyle: typed): typed =
   result = newStmtList()
   let tSym = genSym(nskConst, ":tSym")
   result.add(quote do:
diff --git a/yaml/tojson.nim b/yaml/tojson.nim
index 01ab8d4..df55af6 100644
--- a/yaml/tojson.nim
+++ b/yaml/tojson.nim
@@ -51,7 +51,7 @@ proc jsonFromScalar(content: string, tag: TagId): JsonNode
   try:
     case mappedType
     of yTypeInteger:
-      result = JsonNode(kind: JInt, num: parseBiggestInt(content))
+      result = JsonNode(kind: JInt, num: parseBiggestUInt(content))
     of yTypeFloat:
       result = JsonNode(kind: JFloat, fnum: parseFloat(content))
     of yTypeFloatInf:
